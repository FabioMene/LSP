#!/usr/bin/python3

# Usage: lspc <lsp program source> [output[.lspb]]
# Compiles a lsp source
# If an output file is not specified or the output file
# extension is not .lspb the output format is the
# "serial format", that is, every byte of the bytecode
# is translated to a literal 'w' followed by the byte's
# decimal value.
# The binary format is simply the raw generated bytecode

from sly import Lexer, Parser

from sys import argv, stdin, stdout

from lspc_types import *

infile  = open(argv[1], "r") if len(argv) > 1 else stdin
outfile = stdout

bin_output = False

if len(argv) > 2:
    outf = argv[2]
    
    mode = "w"
    
    if outf.endswith(".lspb"):
        bin_output = True
        mode = "wb"

    outfile = open(outf, mode)


class LSPLexer(Lexer):
    tokens = {
        ID, REGSPEC, OREGSPEC, INTRSPEC, NUMBER, COMMA, COLON
    }
    
    ignore = " \t"
    ignore_comment = r"\#.*"
    
    ID            = r"[a-zA-Z_][a-zA-Z0-9_]*"
    REGSPEC       = r"%"
    OREGSPEC      = r"@"
    ID["ivector"] = INTRSPEC
    NUMBER        = r"-?(0b[01]+|0o[0-7]+|0x[0-9a-fA-F]+|[0-9]+)"
    COMMA         = r","
    COLON         = r":"
    
    def NUMBER(self, tok):
        base = 10
        if tok.value.startswith("0b"):
            base = 2
        elif tok.value.startswith("0o"):
            base = 8
        elif tok.value.startswith("0x"):
            base = 16
        
        tok.value = int(tok.value, base)
        return tok


class LSPParser(Parser):
    tokens = LSPLexer.tokens
    
    @_("REGSPEC ID")
    def register(self, p):
        reg_mapping = {
            "A": 0,
            "B": 1,
            "C": 2,
            "D": 3
        }
        
        if p.ID not in reg_mapping:
            raise SyntaxError(f"'%{p.ID}' is not a valid register")
        
        return ("register", reg_mapping[p.ID])
    
    @_("OREGSPEC ID")
    def out_register(self, p):
        oreg_mapping = {
            "R": 0,
            "G": 1,
            "B": 2
        }
        
        if p.ID not in oreg_mapping:
            raise SyntaxError(f"'@{p.ID}' is not a valid output register")
        
        return ("out_register", oreg_mapping[p.ID])
    
    @_("INTRSPEC NUMBER COLON")
    def interrupt_entry(self, p):
        return ("instruction", "ivec", [("number", p.NUMBER)])
    
    @_("ID COLON")
    def label(self, p):
        return ("label", p.ID)
    
    @_("register", "out_register", "NUMBER", "ID")
    def argument(self, p):
        if type(p[0]) == tuple: return p[0]
        return ("number" if type(p[0]) == int else "id", p[0])
    
    @_("argument", "arglist COMMA argument")
    def arglist(self, p):
        if len(p) == 3:
            return p[0] + [p[2]]
        
        return [p[0]]
    
    @_("ID arglist", "ID")
    def instruction(self, p):
        args = []
        if len(p) == 2:
            args = p.arglist

        return ("instruction", p.ID, args)
    
    @_("label", "instruction", "interrupt_entry")
    def line(self, p):
        return p[0]

    start = "line"


def mnemonic_split(m):
    instmap = {
        "hlt":    [0],
        "sr":     [0, 8, 16],
        "so":     [8, 16],
        "mo":     [0, 8, 16],
        "cmt":    [0],
        "wt":     [0],
        "drjnz":  [0],
        "j":      [0],
        "ivec":   [0],
        "isetpc": [0, 8, 16],
        "iret":   [0]
    }
    
    for i in instmap.keys():
        if m.startswith(i):
            width = 0
            
            if (i + "b") == m:
                width = 8
            
            elif (i + "w") == m:
                width = 16
            
            elif i != m:
                continue
            
            if width not in instmap[i]:
                if width == 0:
                    raise SyntaxError(f"The {i} instruction requires an explicit data width")
                raise SyntaxError(f"The {i} instruction doesn't support {width}bit data")
            
            return i, width
    
    raise SyntaxError(f"The '{m}' mnemonic was not recognized")

def arg_assert(inst, args, types):
    if len(args) != len(types):
        raise SyntaxError(f"The {inst} instruction requires {len(types)} arg(s), {len(args)} found")
    
    for arg, _type, i in zip(args, types, range(len(args))):
        if arg[0] != _type:
            raise SyntaxError(f"The {inst} instruction requires an argument of type {_type} at index {i}, {arg[0]} found")

lexer  = LSPLexer()
parser = LSPParser()

parts = []

for line in infile:
    tokens = list(lexer.tokenize(line[:-1]))
    lexer.lineno += 1
    
    if not tokens:
        continue
    
    line = parser.parse(iter(tokens))
    
    if line[0] == "label":
        parts.append(
            lsp_p_label_t()
            .set(name=line[1])
        )

    elif line[0] == "instruction":
        mnemonic, args = line[1:]
        
        inst, width = mnemonic_split(mnemonic)
        bc = b""
        
        if inst == "hlt":
            arg_assert(inst, args, [])
            bc = bytes([0b0000])
        
        elif inst == "sr":
            arg_assert(inst, args, ["register", "number"])
            reg, num = [arg[1] for arg in args]
            
            if num < 0 or num > 65535:
                raise SyntaxError(f"{num} is out of range for {inst}")
            
            if num > 255:
                if width == 8:
                    raise SyntaxError(f"{num} is out of range for {width} bit data")
                width = 16
            
            else:
                width = 8
            
            if width == 8:
                bc = bytes([(reg << 4) | 0b0001, num])

            else:
                bc = bytes([0b10000000 | (reg << 4) | 0b0001, num & 0xff, num >> 8])
        
        elif inst == "so":
            arg_assert(inst, args, ["out_register", "number"])
            reg, num = [arg[1] for arg in args]
            
            if num < 0 or num > 65535:
                raise SyntaxError(f"{num} is out of range for {inst}")
            
            if num > 255:
                if width == 8:
                    raise SyntaxError(f"{num} is out of range for {width} bit data")
                width = 16
            
            if width == 8:
                bc = bytes([(reg << 4) | 0b0010, num])
            else:
                bc = bytes([0b10000000 | (reg << 4) | 0b0010, num & 0xff, num >> 8])
        
        elif inst == "mo":
            arg_assert(inst, args, ["out_register", "number"])
            reg, num = [arg[1] for arg in args]
            
            if num < -32768 or num > 32767:
                raise SyntaxError(f"{num} is out of range for {inst}")
            
            if num < -128 or num > 127:
                if width == 8:
                    raise SyntaxError(f"{num} is out of range for {width} bit data")
                width = 16

            else:
                width = 8
            
            if width == 8:
                bc = bytes([(reg << 4) | 0b0011, num & 0xff])
            else:
                bc = bytes([0b10000000 | (reg << 4) | 0b0011, num & 0xff, (num & 0xff00) >> 8])
        
        elif inst == "cmt":
            arg_assert(inst, args, [])
            bc = bytes([0b0100])
        
        elif inst == "wt":
            arg_assert(inst, args, [])
            bc = bytes([0b0101])

        elif inst == "ivec":
            arg_assert(inst, args, ["number"])
            
            vect = args[0][1]
            if vect < 0 or vect > 3:
                raise SyntaxError(f"{vect} is not a valid interrupt number")
            
            bc = bytes([(vect << 4) | 0b1001])
        
        elif inst == "iret":
            arg_assert(inst, args, [])
            
            bc = bytes([0b1011])
        
        if bc:
            # append to output only if some bytecode was generated
            parts.append(
                lsp_p_inst_t()
                .set(bytecode=bc)
            )
        
        # From now on there are only jump instructions
        if inst == "drjnz":
            arg_assert(inst, args, ["register", "id"])
            reg, dst = [arg[1] for arg in args]
            
            
            parts.append(
                lsp_p_addr_ref_t()
                .set(inst="drjnz")
                .set(args=[reg])
                .set(opcode="drjnz")
                .set(dst=dst)
                .set(width=8)  # initially 8 bit width
                .set(tmp_dst=0)
            )
            
        elif inst == "j":
            arg_assert(inst, args, ["id"])
            dst = args[0][1]
            
            parts.append(
                lsp_p_addr_ref_t()
                .set(inst="j")
                .set(args=[])
                .set(opcode="jump")  # initially a relative jump
                .set(dst=dst)
                .set(width=8)
                .set(tmp_dst=0)
            )
        
        elif inst == "isetpc":
            arg_assert(inst, args, ["id"])
            dst = args[0][1]
            
            parts.append(
                lsp_p_addr_ref_t()
                .set(inst="isetpc")
                .set(args=[])
                .set(opcode="isetpc")
                .set(dst=dst)
                .set(width=8)
                .set(tmp_dst=0)
            )

# Check the references
for part in parts:
    if part.type != lsp_part_types_e.T_ADDR_REF:
        continue
    
    for dst_part in parts:
        if dst_part.type == lsp_part_types_e.T_LABEL and dst_part.name == part.dst:
            break
    
    if dst_part.type != lsp_part_types_e.T_LABEL or dst_part.name != part.dst:
        raise ValueError(f"The label called '{part.dst}' could not be found")
    
    part.dst = dst_part


# Compute the addresses
while True:
    addr = 0x0000
    for part in parts:
        part.tmp_addr = addr
        
        if part.type == lsp_part_types_e.T_INST:
            addr += len(part.bytecode)
        
        elif part.type == lsp_part_types_e.T_ADDR_REF:
            addr += 1 + part.width // 8
    
    # Compute references. If some instruction's width is not enough to encode the address/offset
    # we change the instruction, then we redo the address computation
    _restart = False
    for part in parts:
        if part.type != lsp_part_types_e.T_ADDR_REF:
            continue
        
        if part.inst == "j":
            if part.opcode == "jump":
                off = part.dst.tmp_addr - (part.tmp_addr + 2)  # the instruction jumps from the byte
                                                               # immediatly after it's bytecode
                # check if we can encode the relative jump
                if off > 127 or off < -128:
                    part.opcode = "jump_abs"  # We need an absolute jump
                    part.width  = 8

                    # redo
                    _restart = True
                    break
                
                part.tmp_dst = off
            
            elif part.opcode == "jump_abs":
                dest = part.dst.tmp_addr
                
                if off > 255 and part.width == 8:
                    # Retry to encode this jump in 16 bits
                    part.width = 16

                    # redo
                    _restart = True
                    break

                if off > 65535:
                    # not likely
                    raise ValueError("jump_abs overflow")
                
                part.tmp_dst = dest
        
        elif part.inst == "drjnz":
            off = part.dst.tmp_addr - (part.tmp_addr + 1 + part.width // 8)
            
            if (off > 127 or off < -128) and part.width == 8:
                part.width = 16
                
                # redo
                _restart = True
                break
            
            if off > 32767 or off < -32768:
                raise ValueError("drjnz overflow")
            
            part.tmp_dst = off
        
        elif part.inst == "isetpc":
            dst = part.dst.tmp_addr
            
            if dst > 255 and part.width == 8:
                part.width = 16

                # redo
                _restart = True
                break
            
            if dst > 65535:
                raise ValueError("isetpc overflow")
            
            part.tmp_dst = dst
    
    if _restart:
        continue
    
    
    # Now all the remaining instructions can be encoded in their .width
    # so we convert them to bytecode
    for i, part in zip(range(len(parts)), parts):
        if part.type != lsp_part_types_e.T_ADDR_REF:
            continue
        
        bc = b""
        
        if part.opcode == "jump":
            bc = bytes([0b0111, part.tmp_dst & 0xff])
        
        elif part.opcode == "jump_abs":
            if part.width == 8:
                bc = bytes([0b1000, part.tmp_dst & 0xff])
            else:
                bc = bytes([0b10001000, part.tmp_dst & 0xff, (part.tmp_dst & 0xff00) >> 8])
        
        elif part.opcode == "drjnz":
            if part.width == 8:
                bc = bytes([0b0110 | (part.args[0] << 4), part.tmp_dst & 0xff])
            else:
                bc = bytes([0b10000000 | (part.args[0] << 4) | 0b0110, part.tmp_dst & 0xff, (part.tmp_dst & 0xff00) >> 8])
        
        elif part.opcode == "isetpc":
            if part.width == 8:
                bc = bytes([0b1010, part.tmp_dst & 0xff])
            else:
                bc = bytes([0b10001010, part.tmp_dst & 0xff, (part.tmp_dst & 0xff00) >> 8])

        parts[i] = lsp_p_inst_t().set(bytecode=bc)

    # If we reach this point all bytecode was generated
    break


bytecode = b""

for part in parts:
    if part.type == lsp_part_types_e.T_INST:
        bytecode += part.bytecode

if bin_output:
    outfile.write(bytecode)

else:
    for byte in bytecode:
        outfile.write(f"w{byte}")

